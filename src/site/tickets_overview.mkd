## Tickets

*PREVIEW 1.4.0*

### Design

The Tickets feature of Gitblit is designed based on the user interface of Github's Issues and the workflow of Gerrit.  Gitblit stores each ticket as a journal (list of changes).  A ticket journal is retrieved from the chosen persistence engine and an effective ticket is built by applying the ordered changes from the journal.  These changes are usually additive, but in some cases a change may represent a deletion.  All tickets are indexed by Lucene against which all ticket queries are executed.

### Status

The Tickets feature is very much incomplete and is under-going active development.

#### Persistence Choices

**Repository Ticket Service (recommended)**
By default, your ticket data is persisted on an orphan branch within your repository.  This allows you to easily clone your tickets to client working copies using [Barnum](http://barnum.gitblit.com).  You may optionally configure a Redis server which Gitblit will use to cache tickets for performance and/or interoperability with other services on your network.

**Redis Tickset Service**
You may choose to only persist your tickets in a Redis data store.  In this configuration no ticket data is stored in your repository.  Make sure you configure Redis for durability!!  You may still use [Barnum](http://barnum.gitblit.com) but you will not have client-side Tickets.

#### Limitations

- Ticket data is non-relational to user accounts.  If *james* comments on a ticket, *james* is preserved forever in the ticket data.  This is similar to git commits which are also non-relational.
- The *Repository Ticket Service* does not currently permit ticket-pushes from clones.  This is an on-going area of exploration and may be possible given that a ticket is constructed from an append-only journal of changes.
- Gitblit does not currently offer a complete code review experience.  For example, per-file/per-line comments are not currently implemented.

#### How did Github influence the design of Tickets?

**UI.** Github has a very pleasant, efficient, and clean UI for their Issues.  It does what it needs to do and is not overly complex.

Gitblit's Tickets UI is modeled after Github's UI design.

#### How did Gerrit influence the design of Tickets?

**Workflow.** Gerrit employs a clever patch workflow that requires repeated use of `git commit --amend` to hone and polish a commit until it is ready for merging to the proposed integration branch.  This technique is a much improved analog of patch revision.

Gitblit uses Gerrit's workflow design of *magic branches* and *change-id*s.

### Rules/Requirements/Differences

- Commits for a ticket must have a *change-id* footer in the commit message.  This value links your commit to a ticket.  If no ticket is found that matches the *change-id*, a new ticket is created.
<pre>Fix NPE in Lucene indexer

A null pointer exception could be thrown in generation of the query if the tag
query parameter was null.

Change-Id: I6f25aa3ccd75d4ccc20ccd2864dd23c14171c7fb</pre>
- A *change-id* is an alias for an integer *ticket id*.  A *change-id* can not be re-used for multiple tickets.  This is a distinction from Gerrit where it is possible that a *change-id* may be used for multple change reviews, for example merging a patchset to multiple branches.
- Non-first-parent descendents of merge commits are not required to have a change-id.  This is another important distinction from Gerrit.
- Gitblit Tickets cannot be used concurrently with Gerrit because of likely integer id collisions.

### Nomenclature

1. The organizational unit of the Tickets feature is the *ticket*.
2. A *ticket* can be used to collaborate on, review, or develop a *patch*.
3. A *patch (patch revision)* is a single commit on it's own branch in your repository.
4. A *ticket* monitors the development of a *patch* by tracking *revisions* of the *patch* using Git change refs.
5. A *patch revision* (commit) may depend on a *patch revision* (commit) from another *ticket*.

### Types of Tickets

Gitblit has two primary ticket types with a subtle distinction between them.

1. *Change Ticket*.  This ticket type is created when a contributor pushes a new change-id to Gitblit.  The Change Ticket is used to polish and hone the patch.  The title and body of the ticket are the title and body of the commit message.  With each patch revision, the title and body are also updated - if they change.  The title and body of a *Change Ticket* may **not** be edited from the web ui.

2. *Request Ticket*.  This ticket type is manually created by a user.  The title and body are editable through the web ui and are not affected by any pushes of a patch.  A *Request Ticket* is assigned a *change-id* and accepts patches, just like a *Change Ticket*.

The primary difference between these two tickets is how they are created and this difference dictates slightly different behavior concerning the ticket's title and body.  Otherwise, both types are identical.

The *Change Ticket* corresponds to Gerrit's *Change Review*, where pushing a commit starts the discussion.  The *Request Ticket* corresponds to a standard issue-tracker where the discussion is started by a report or request.

### Why not Pull/Merge Requests?

This is a matter of preference.  Pull/Merge Requests are appropriate for integrating large features which are best developed over many commits.  The Pull/Merge request feature promotes the *create more commits* workflow regardless of the size of the contribution.  In contrast, the *patch* approach optimizes the workflow for smaller-sized contributions which should be more prevalent.

It should be noted that there are two techniques when using the *patch* approach for larger contributions.

1. Patch Series.
Since a *patch* is a commit it has at least one parent.  In the event that the patch has only one parent, that parent may be an already integrated commit **or** it may be another *patch*.  Gitblit tracks the *parent* and *child* dependencies of your *patch* allowing you to develop several dependent patches in a series of tickets.
2. Merge Patches.
For larger contributions, you could develop on a separate branch and push a merge patch to Gitblit.  This allows you to develop on your branch without having to create a ticket for every commit on that branch.  You could think of this as a creating a Pull/Merge Request from a merge commit.

## Quick Outline on using Tickets

### RefSpec Tricks

Gitblit supports setting ticket fields embedded in the patch push refspec.

    refs/for/master%topic=bug/42,r=james,m=1.4.1,cc=dave,cc=mark

You may set the topic, the milestone, the reviewer/handler, and subscribe users to the ticket.

#### Special RefSpec Parameters

| parameter | description                                                     |
| --------- | --------------------------------------------------------------- |
| topic     | assign a *topic* to the pushed patches                          |
| r         | set the *assigned to* / *reviewer*                              |
| m         | set the *milestone* for patch integration                       |
| cc        | subscribe this account to the notifications (multiples allowed) |

## Progress

### Mechanics

- tickets stored on branch within repository as a journal (discrete list of changes)
- tickets stored in Redis as a journal (discrete list of changes)
- tickets indexed in global Lucene index
- tickets optionally cached in Redis

### What it does (DONE list)

- creates ticket on push of new change-id to magic branch
- rejects first-parent descendant commits pushed to magic branch w/o change-id
- closes tickets & marks as merged on push of change-id to integration branch
- emails on ticket creation, patch revision, ticket merge, comment added
- displays ticket data, comments, and patch revisions
- markdown support in comments and ticket body
- add comment with preview
- comment permalinks
- current patch revision git menu, barnum menu, compare menu
- current patch revision changed path list with diff links
- tests current patch revision for merge & cherry-pick

### What it does not do (TODO list)

- support repository renaming (Lucene)
- support delete repository (Lucene)
- symlink ticket ids?
- reflog polishing
- commit page -> ticket linking
- assignment selector
- milestone selector
- edit details
- edit comment
- delete comment
- close ticket
- reopen ticket
- my tickets page
- closed tickets query
- email on close/reopen
- reference changeid after merge/close
- new/update/close ticket hooks
- manual ticket creation
- voting
- line comments
- ticket patch hooks: new ticket, update ticket, close ticket

