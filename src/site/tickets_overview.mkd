## Tickets

*PREVIEW 1.4.0*

### Design

The Tickets feature of Gitblit is designed around the concept of collaborative branches.  It mixes elements inspired from Github's and Bitbucket's user interface and combines that with some flavoring from Gerrit.

Gitblit stores each ticket as a journal (list of changes).  A ticket journal is retrieved from the chosen persistence engine and an effective ticket is built by applying the ordered changes from the journal.  These changes are usually additive, but in some cases a change may represent a deletion.  All tickets are indexed by Lucene against which all ticket queries are executed.

### Status

The Tickets feature is fairly functional but there are several areas which need further enhancement.

#### Refinements

- The ticket page is very stateful and depends on your Wicket session.  I'm not in love with this but it's acceptable for now.
- Might be nice to process Markdown previews client-side rather than round-tripping to Gitblit (another stateful example).
- Would be nice to have the ticket description be collapsible

#### TODO

- needs an Edit Ticket Details page
- needs a My Tickets page
- would be nice to edit a comment
- would be nice to delete a comment
- web ui for adding, editing, and deleting miletones
- hook points on new/updated/closed ticket
- REST API for tools

#### Persistence Choices

Gitblit's ticket data is based on a ridiculously simple concept: a ticket is the end result of applying a sequence of changes to an empty ticket.  Each change is serialized as JSON and stored in a journal.  The journal may be a simple text file (`journal.json`) or it may be a Redis LIST or some future persistence type.

**File Ticket Service**
Your ticket data is persisted to `journal.json` in a directory within your repository.

**Branch Ticket Service**
Your ticket data is persisted to `journal.json` which is stored on an orphan branch within your repository.  This allows you to easily clone your tickets to client working copies or to mirrors.  There is a work-in-progress tool to make this fun and easy([Barnum](http://barnum.gitblit.com)) but it has not kept up with the datamodel changes so it is currently very, very broken.

**Redis Tickset Service**
Your ticket data is persisted in a Redis data store.  Make sure you configure Redis instance for durability!!  This particular service is highly-scalable and you can use all of the power of Redis and clusters, should you really want.

#### Limitations

- Ticket data is non-relational to user accounts.  If *james* comments on a ticket, *james* is preserved forever in the ticket data.  This is similar to git commits which are also non-relational.
- The *Branch Ticket Service* does not currently permit ticket-pushes from clones.  This is an on-going area of exploration and may be possible given that a ticket is constructed from an append-only journal of changes.
- Gitblit does not currently offer commit nor line review features.

#### How did Github influence the design of Tickets?

**UI.** Github has a very pleasant, efficient, and clean UI for their Issues.  It does what it needs to do and is not overly complex.

Gitblit's Tickets querying ui is modeled after Github's ui design.

#### How did BitBucket influence the design of Tickets?

**UI.** BitBucket has a clean issue viewing ui.

Gitblit's Ticket page  ui is inspired by BitBucket.

**Pull Requests.** BitBucket has a very cool idea of creating a pull request from a branch within the same repository.  Github may also be able to do this, but it is not as well-developed, front-and-center as BitBucket's implementation.

#### How did Gerrit influence the design of Tickets?

**Workflow.** Gerrit employs a clever patch workflow that requires repeated use of `git commit --amend` to hone and polish a commit until it is ready for merging to the proposed integration branch.  This technique is a much improved analog of patch revision.

After working with this design for 6 months and dogfooding dozens of commits and hundreds of amends I concluded that this workflow doesn't scale for active, in-development code.  It also introduces many, many refs.

Gitblit has adopted Gerrit's *magic branch* design but not the *change-id* requirement.

### Rules/Requirements/Differences

### Nomenclature

1. The organizational unit of the Tickets feature is the *ticket*.
2. A *ticket* can be used to report a bug, request an enhancement.  It can also be used to collaborate on a *patchset* that addresses the request.
3. A *patchset* is a series of commits from a merge base that exists in the target branch of your repository to the tip of the patchset.  A patchset may only contain a single commit, or it may contain dozens.  This is similar in idea to the commits in a *Pull Request*.  One important distinction here is that in Gitblit, *Patchsets* are versioned.
4. A *ticket* monitors the development of a *patchset* by tracking *revisions* of the *patchset* using Git change refs.  This is similar in design to Gerrit, but different in that only the tip gets a change ref.  In Gerrit, every commit gets a change ref and a corresponding Review (like a Ticket).

### Types of Tickets

Gitblit has two primary ticket types with a subtle distinction between them.

1. *Proposal Ticket*.  This ticket type is created when a contributor pushes a single commit to Gitblit using the **new** or **for** magic ref.  The title and description of the ticket are the title and body of the commit's message.  If you want to adopt a Gerrit-style workflow then you may *--amend* this commit and push it again and again.  Each *--amend* and push will update the Ticket's title and description from the commit message.  However, if you push new commits that build on the initial commit then this title/description updating behavior does not apply.

2. *Request Ticket*.  This ticket type is manually created by a user.  These tickets may be *Bug*, *Enhancement*, *Task*, or *Question* tickets.

The only difference between these two ticket types is how they are created (on-push or through the ui) and the aforementioned special behavior of amending the initial commit.  Otherwise, both types are identical.

### Why not Pull/Merge Requests?

Pull Requests assume the following workflow:

1. Fork RepoA
2. Clone MyRepoA
3. Create branch and hack on contribution
4. Push new branch upstream to MyRepoA
5. Open Pull Request from MyRepoA -> RepoA
6. RepoA owner pulls from MyRepoA

Gitblit's flow looks like this:

1. Clone RepoA
2. Create branch and hack on contribution
3. Push to magic branch of RepoA
4. RepoA owner pulls from RepoA

The Gitblit flow eliminates the 4-repository design of a pull request (canonical, canonical working copy, fork, & fork working copy). In favor of a 3-repository design (canonical, canonical working copy, clone working copy).  In the future, Gitblit may support creating a *Proposal Ticket* from a branch in a fork just like a Pull Request, but right now you can create a Proposal Ticket without needing that extra repository.

## Quick Outline on using Tickets

### RefSpecs

Gitblit supports several magic refs.

| magic ref            | description                                  |
| :------------------- | :------------------------------------------- |
| **to create a ticket**                                             ||
| refs/for/new         | new ticket for default branch                |
| refs/for/default     | new ticket for default branch                |
| refs/for/{branch}    | new ticket for specified branch              |
|                                                                    ||
| **to add a patchset to an existing ticket**                        ||
| refs/tickets/{id}    | fast-forward patchset for existing ticket    |
|                                                                    ||
| **to amend, rebase, or squash the patchset of a ticket**           ||
| refs/for/{id}        | non-fast-forward update to existing patchset |

### Creating a Proposal Ticket

*Who can create a proposal ticket?*  Any authenticated user who can clone your repository.

    git checkout -b mytopic
    ...add a single commit...
    git push origin HEAD:refs/for/new

### Creating a Patchset for an Existing Ticket

*Who can create a patchset for an existing ticket?*  Any authenticated user who can clone your repository.

    git checkout -b mytopic
    ...add one or more commits...
    git push origin HEAD:refs/tickets/{id}

### Add to a Patchset for an Existing Ticket

*Who can add commits to an existing patchset?*

1. The author of the ticket
2. The author of the initial patchset
3. Any user with write (RW) permissions to the repository
4. Any user specified as a Reviewer for the ticket (currently no way to set that)

    git fetch origin refs/tickets/{id}
    git checkout -b ticket/{id} FETCH_HEAD
    ...add one or more commits...
    git push origin HEAD:refs/tickets/{id}

### Rewriting a Patchset (amend, rebase, squash)

*Who can rewrite a patchset?*  See the above rules for who can add commits to a patchset. You do **not** need rewind (RW+) to the repository to push a non-fast-forward patchset revision.

    git fetch origin refs/tickets/{id}
    git checkout -b ticket/{id} FETCH_HEAD
    ..amend, rebase, squash..
    git push origin HEAD:refs/for/{id}

### RefSpec Tricks

Gitblit supports setting ticket fields embedded in the patch push refspec.

    refs/for/master%topic=bug/42,r=james,m=1.4.1,cc=dave,cc=mark

| parameter | description                                                     |
| :-------- | :-------------------------------------------------------------- |
| topic     | assign a *topic* to the ticket                                  |
| r         | set the *responsible* user                                      |
| m         | set the *milestone* for patchset integration                    |
| cc        | add this account to the *watch* list (multiple ccs allowed)     |
