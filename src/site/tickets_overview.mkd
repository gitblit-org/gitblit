## Tickets

*PREVIEW 1.4.0*

### Design

The Tickets feature of Gitblit is designed around the concept of collaborative branches and mixes elements inspired from GitHub, BitBucket, and Gerrit.

Gitblit stores each ticket as a journal (list of changes).  A ticket journal is retrieved from the chosen persistence engine and an effective ticket is built by applying the ordered changes from the journal.  These changes are usually additive, but in some cases a change may represent a deletion.  Tickets are indexed by Lucene against which all ticket queries are executed.

### Status

The Tickets feature is fairly functional but there are several areas which need further refinements.

#### What is working

- Ticket creation and editing
- Ticket creation on patchset push
- Comments with Markdown syntax support
- Rich email notifications
- Patchset handling
- Voting
- Watching
- Mentions
- Partial milestone support
- Querying
- Searching
- Is Mergeable test on view ticket page load
- Close-on-push of detected merge
- Multiple backend choices

#### TODO (soon)

- hook the Merge button to the already implemented server-side merge logic
- need a My Tickets page
- web ui for adding, editing, and deleting miletones
- continue cleanup of code and templates

#### TODO (later)
- would be nice to have a collapsible ticket description (e.g. AUI expander)
- would be nice to edit a comment
- would be nice to delete a comment
- hook points on new/updated/closed ticket
- REST API for tooling
- The ticket page is very stateful and depends on your Wicket session.  I'm not in love with this but it's acceptable for now.
- Might be nice to process Markdown previews client-side rather than round-tripping to Gitblit (another stateful example).  Perhaps using AngularMarkdown?

#### Persistence Choices

Gitblit's ticket data is based on a ridiculously simple concept: a ticket is the end result of applying a sequence of changes to an empty ticket.  Each change is serialized as JSON and stored in a journal.  The journal may be a simple text file (`journal.json`) or it may be a Redis LIST or some future persistence type.

All ticket services inherit from the same base class which handles most of the high level logic for ticket management including caching, milestones (stored in .git/config), indexing, queries, and searches.

**File Ticket Service**
Your ticket changes are persisted to `{id}/journal.json`.  These journals are stored on the filesystem in a directory within your repository.

**Branch Ticket Service**
Your ticket changes are persisted to `{id}/journal.json`.  These journals are stored on an orphan branch within your repository.  This allows you to easily clone your tickets to client working copies or to mirrors.  There is a work-in-progress client-side tool to make this easy ([Barnum](http://barnum.gitblit.com)) but it has not kept up with the December/January datamodel changes so it is currently very, very broken.

**Redis Tickset Service**
Your ticket changes are persisted to a Redis data store.  *Make sure you configure your Redis instance for durability!!*  This particular service is highly-scalable and very fast.  Plus you can use all of the power of Redis and clusters, should you want.  The main downside to this service is that Redis is primarily a Unix service.  While there is a Windows port partially maintained by Microsoft, it hasn't seen much love in a while.

#### Limitations

- Ticket data is non-relational to user accounts.  If *james* comments on a ticket, *james* is preserved forever in the ticket data.  This is similar to git commits which are also non-relational.  This could be overcome by wrting a tool to deserialize all the journals and rewrite the authors, so it is not impossible to change, but following KISS - ticket data is non-relational to user accounts.
- The *Branch Ticket Service* does not currently permit ticket journal pushes from clones.  This is an area of exploration and may be possible given that a ticket is constructed from an append-only journal of changes.
- Gitblit does not currently offer commit nor line review features.

#### How did GitHub influence the design of Tickets?

**UI.** GitHub has a very efficient, and clean UI for their Issues.  It offers the basics and give you labels to fill in the gaps.  It is not overly complex.

Gitblit's Ticket querying and discussion ui are modeled after GitHub's ui design.

#### How did BitBucket influence the design of Tickets?

**UI.** BitBucket has a more rigid issue tracker and a clean issue viewing ui.  The rigidity makes it more like a traditional issue tracker with status, priority, kind, etc.

Gitblit's Ticket page ui is inspired by BitBucket.  Gitblit Tickets have state and types, which makes it a more rigid/traditional tracker.  Atlassian has also gifted the community with the AUI, a webapp toolkit of CSS & JS.  Gitblit has borrowed some of these Apache licensed CSS elements.

**Branch Pull Requests.** BitBucket has a very cool idea of creating a pull request from a branch within the same repository.  GitHub may also be able to do this, but it is not as well-developed or front-and-center like BitBucket's implementation.

#### How did Gerrit influence the design of Tickets?

**Patchsets.** Gerrit employs a clever patchset workflow that requires repeated use of `git commit --amend` to hone and polish a commit until it is ready for merging to the proposed integration branch.  This technique is a much improved analog of patch revision.

After working with this design for many months and dogfooding dozens of tickets with hundreds of amends, rebases, and squashes, I have concluded that this workflow doesn't scale for active, in-development code.  It is best suited for it's original intention: code-review.  It also introduces many, many refs.

Gitblit has adopted Gerrit's *magic branch* design and change refs but not the *change-id* requirement.

### Nomenclature

1. The organizational unit of the Gitblit Tickets feature is the *ticket*.
2. A *ticket* can be used to report a bug, request an enhancement, ask a question, etc.  A ticket can also be used to collaborate on a *patchset* that addresses the request.
3. A *patchset* is a series of commits from a merge base that exists in the target branch of your repository to the tip of the patchset.  A patchset may only contain a single commit, or it may contain dozens.  This is similar to the commits in a *Pull Request*.  One important distinction here is that in Gitblit, each *Patchset* is versioned and can be completely rewritten as needed without losing the previous patchsets.
4. A *ticket* monitors the development of a *patchset* by tracking *revisions* of the *patchset* using Git change refs.  This is similar in design to Gerrit, but different in that only the tip gets a change ref.  In Gerrit, every commit in the series gets a change ref and a corresponding Review (Ticket).

### Types of Tickets

Gitblit has two primary ticket types with a subtle distinction between them.

1. *Proposal Ticket*.  This ticket type is created when a contributor pushes a single commit to Gitblit using the **new** or **for** magic ref.  The title and body of the commit message become the title and description of the ticket.  If you want to adopt a Gerrit-style workflow then you may *--amend* this commit and push it again and again.  Each *--amend* and push will update the Ticket's title and description from the commit message.  However, if you push new commits that build on the initial commit then this title/description updating behavior will not apply.

2. *Request Ticket*.  This is a ticket that is manually created by a user using the web ui.  These tickets have assignable types like *Bug*, *Enhancement*, *Task*, or *Question*.

The only difference between these two ticket types is how they are created (on-push or through the ui) and the aforementioned special behavior of amending the initial commit.  Otherwise, both types are identical.

### Why not Pull/Merge Requests?

Pull Requests require the following workflow:

1. Fork RepoA -> MyRepoA
2. Clone MyRepoA
3. Create branch in MyRepoA clone and hack on contribution
4. Push new branch upstream to MyRepoA
5. Open Pull Request from MyRepoA -> RepoA
6. RepoA owner pulls from MyRepoA

Gitblit's flow looks like this:

1. Clone RepoA
2. Create branch in RepoA clone and hack on contribution
3. Push to magic branch of RepoA
4. RepoA owner pulls from RepoA

The Gitblit flow eliminates the 4-repository design of a pull request (canonical, canonical working copy, fork, & fork working copy). In favor of a 3-repository design (canonical, canonical working copy, clone working copy).

You might wonder: is it a good idea to allow users' to push into the canonical repository?  And the answer is, it's no different than a pull request.  When you open a pull request from MyRepoA to RepoA, your code is already being pushed to a private branch in RepoA.  This workflow just cuts out that extra repository and extra step.

Additionally, because the change proposal is not linked to a user's personal fork it is possible to allow others to collaborate on the patchset.

## Quick Outline on using Tickets

### Creating a Proposal Ticket

*Who can create a proposal ticket?*  Any authenticated user who can clone your repository.

    git checkout -b mytopic
    ...add a single commit...
    git push origin HEAD:refs/for/new

### Creating a Patchset for an Existing Ticket

*Who can create a patchset for an existing ticket?*  Any authenticated user who can clone your repository.

    git checkout -b mytopic
    ...add one or more commits...
    git push origin HEAD:refs/tickets/{id}

### Add to a Patchset for an Existing Ticket

*Who can add commits to an existing patchset?*

1. The author of the ticket
2. The author of the initial patchset
3. Any user with write (RW) permissions to the repository
4. Any user specified as a Reviewer for the ticket (currently no way to set that)


    git fetch origin refs/tickets/{id}
    git checkout -b ticket/{id} FETCH_HEAD
    ...add one or more commits...
    git push origin HEAD:refs/tickets/{id}

### Rewriting a Patchset (amend, rebase, squash)

*Who can rewrite a patchset?*  See the above rules for who can add commits to a patchset. You do **not** need rewind (RW+) to the repository to push a non-fast-forward patchset revision.

    git fetch origin refs/tickets/{id}
    git checkout -b ticket/{id} FETCH_HEAD
    ..amend, rebase, squash..
    git push origin HEAD:refs/for/{id}

### RefSpecs

Gitblit supports several magic refs.

#### to create a proposal ticket

| magic ref            | description                                  |
| :------------------- | :------------------------------------------- |
| refs/for/new         | new ticket for default branch                |
| refs/for/default     | new ticket for default branch                |
| refs/for/{branch}    | new ticket for specified branch              |

#### to add a patchset to an existing ticket

| magic ref            | description                                  |
| :------------------- | :------------------------------------------- |
| refs/tickets/{id}    | fast-forward patchset for existing ticket    |


#### to amend, rebase, or squash the patchset of a ticket

| magic ref            | description                                  |
| :------------------- | :------------------------------------------- |
| refs/for/{id}        | non-fast-forward update to existing patchset |

### RefSpec Tricks

Gitblit supports setting ticket fields embedded in the patch push refspec.

    refs/for/master%topic=bug/42,r=james,m=1.4.1,cc=dave,cc=mark

| parameter | description                                                     |
| :-------- | :-------------------------------------------------------------- |
| topic     | assign a *topic* to the ticket                                  |
| r         | set the *responsible* user                                      |
| m         | set the *milestone* for patchset integration                    |
| cc        | add this account to the *watch* list (multiple ccs allowed)     |
